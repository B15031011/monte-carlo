demo()
plotmath
getwd()
# ------Input to the program -----------------------------------------------
# -------------------------------------------------------------------------------
# -------------------------------------------------------------------------------
# ------Input to the program -----------------------------------------------
# -------------------------------------------------------------------------------
source("~/co2/script.R")
View(Bij)
View(try)
# -------------------------------------------------------------------------------
# ------Input to the program -----------------------------------------------
# -------------------------------------------------------------------------------
yearB <- 1980 # Base year
year <- 1981 # Year of calculations
C0 <- 4771.5 # CO2 emissions, base year
C1 <- 4645.9 # CO2 emissions, calculations' year
G0 <- 5834.0 # GDP, base year
G1 <- 5982.1 # GDP, calculations' year
E0 <- 78.07 # Energy, base year
E1 <- 76.11 # Energy, calculations' year
P0 <- 227.2 # Population, base year
P1 <- 229.5 # Population, calculations' year
eps <- 10^-7 # preciseness of integration
# --------- Data in terms of the base year --------------------------------
z1 <- C1/C0 # CO2 emissions in terms of the base year
x1 <- G1/G0 # GDP in terms of the base year
x3 <- E1/E0 # Energy in terms of the base year
x5 <- P1/P0 # Population in terms of the base year
# ----- Relative indicators in terms of the base year ----------------------
x2 <- z1/x1 # CO2/GDP
x4 <- z1/x3 # CO2/Energy
x6 <- z1/x5 # CO2/Population
x7 <- x1/x5 #GDP/Population
x8 <- x3/x1 #Energy/GDP
# --------------------------------------------------------------------------------
# - GDIM algorithm. Exponential dynamics assumed. In terms of base year -
zf <- function(t)(C1/C0)^t #CO2
x1f <- function(t) (G1/G0)^t #GDP
x3f <- function(t) (E1/E0)^t #Energy
x5f <- function(t) (P1/P0)^t #Population
x2f <- function(t) zf(t)/x1f(t) #CO2/GDP
x4f <- function(t) zf(t)/x3f(t) #CO2/Energy
x6f <- function(t) zf(t)/x5f(t) #CO2/Population
x7f <- function(t) x1f(t)/x5f(t) #GDP/Population
x8f <- function(t) x3f(t)/x1f(t) #Energy/GDP
# ---- Projection operator ---------------------------------------------------
Bij <- function(t,i1,j1){
IdM <- array(1:64, dim=c(8,8)) # Identity matrix
IdM[] <- 0
for (ii in 1:8) {IdM[ii,ii] <-1}
PhiX <- array(1:32, dim=c(8,4)) # Jacobian matrix
PhiX[] <- 0
PhiX[1,1] <- x2f(t)
PhiX[2,1] <- x1f(t)
PhiX[3,1] <- -x4f(t)
PhiX[4,1] <- -x3f(t)
PhiX[3,2] <- x4f(t)
PhiX[4,2] <- x3f(t)
PhiX[5,2] <- -x6f(t)
PhiX[6,2] <- -x5f(t)
PhiX[1,3] <- 1
PhiX[5,3] <- -x7f(t)
PhiX[7,3] <- -x5f(t)
PhiX[1,4] <- -x8f(t)
PhiX[3,4] <- 1
PhiX[8,4] <- -x1f(t)
PhiXT <- t(PhiX) # PhiX transposed
Prod_PT_Px <- array(1:16, dim=c(4,4))
Prod_PT_Px[] <- 0
Prod_PT_Px <- PhiXT %*% PhiX # Product of Phi_X_T*Phi_X
PT_P_1 <- solve(Prod_PT_Px) # Inverse of the Phi_X_T*Phi_X
# ------------------------------------------------------------------------------
B <- array(1:64, dim=c(8,8))
B[] <- 0
B <- IdM - PhiX %*% PT_P_1 %*% PhiXT
return(B[i1,j1])}
Dz_vect <- array(1:8, dim=c(8))
Dz_vect[] <- 0
for (i_ind in (1:8)) {
if (i_ind == 1)
try <- function(t) (x1f(t)*Bij(t,2,i_ind)+x2f(t)*Bij(t,1,i_ind))*x1f(t)*log(x1)
else
if (i_ind == 2)
try <- function(t) (x1f(t)*Bij(t,2,i_ind)+x2f(t)*Bij(t,1,i_ind))*x2f(t)*log(x2)
else
if (i_ind == 3)
try <- function(t) (x1f(t)*Bij(t,2,i_ind)+x2f(t)*Bij(t,1,i_ind))*x3f(t)*log(x3)
else
if (i_ind == 4)
try <- function(t) (x1f(t)*Bij(t,2,i_ind)+x2f(t)*Bij(t,1,i_ind))*x4f(t)*log(x4)
else
if (i_ind == 5)
try <- function(t) (x1f(t)*Bij(t,2,i_ind)+x2f(t)*Bij(t,1,i_ind))*x5f(t)*log(x5)
else
if (i_ind == 6)
try <- function(t) (x1f(t)*Bij(t,2,i_ind)+x2f(t)*Bij(t,1,i_ind))*x6f(t)*log(x6)
else
if (i_ind == 7)
try <- function(t) (x1f(t)*Bij(t,2,i_ind)+x2f(t)*Bij(t,1,i_ind))*x7f(t)*log(x7)
else
if (i_ind == 8)
try <- function(t) (x1f(t)*Bij(t,2,i_ind)+x2f(t)*Bij(t,1,i_ind))*x8f(t)*log(x8)
else {print("Error in the number of factors");stop}
# ------------ Numerical integration using the Simpson's method ------------
a <- 0 # initial point
b <- 1 # endpoint
n <- 2 # to begin iterations
y0 <- try(a)
yn <- try(b)
ymid <- try((a+b)/2)
del_x <- (b-a)/n
k <- del_x/3
Int_0 <- k*(y0+4*ymid + yn)
err <- eps+1 # Initializing the error to start
Int_n <- Int_0
IntSimp <- Int_0
while (err > eps){
n <- 2*n
del_x <- (b-a)/n
k <- del_x/3
Int_2n <- 0
for (ni in (1:n-1)){Int_2n <- Int_2n + try(a + ni*del_x)*(2+(1+(-1)^(ni+1)))}
Int_2n <- k*(Int_2n + y0 + yn)
err <- abs(Int_2n - Int_n)/15
if (err < eps) {IntSimp <- Int_2n; break}
else {Int_n <- Int_2n}}
Dz_vect[i_ind] <- IntSimp
} # end of the loop by indicators
sum_fact <- 0; for (i_sum in 1:8) sum_fact <- sum_fact + Dz_vect[i_sum]
# --- Print out input data, results, and control numbers ----------------------
"Input data"
"Base year"; yearB
"Year of calculations"; year
"CO2 emissions, base year"; C0
"CO2 emissions, calculations year"; C1
"GDP, base year"; G0
"GDP, calculations year"; G1
"Energy, base year"; E0
"Energy, calculations year"; E1
"Population, base year"; P0
"Population, calculations year";P1
# ------------------------------------------------------------------------------
"In terms of the base year"
"CO2 emissions"; z1
"GDP"; x1
"Energy"; x3
"Population"; x5
"Relative indicators in terms of the base year"
"CO2/GDP"; x2
"CO2/Energy"; x4
"CO2/Population"; x6
"GDP/Population"; x7
"Energy/GDP"; x8
# ------------------------------------------------------------------------------
"Output data"
"Contributions to the rate of change in CO2 emissions"
source("~/co2/script.R")
getwd()
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
source("~/co2/script.R")
